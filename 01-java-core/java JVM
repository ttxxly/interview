本篇涉及所有常见的虚拟机面试题。

## 基础概念

#### Java 是如何实现跨平台的？

```text
我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。
Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说
  只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。

而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，
就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。
```

#### 什么是 JVM ？

```text
JVM，即 Java Virtual Machine，Java 虚拟机。

它通过模拟一个计算机来达到一个计算机所具有的的计算功能。

JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了
  与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。
```

#### 能说说常用的几个JVM配置参数吗？

```text
堆内存分配：
  JVM初始分配的内存由-Xms指定，默认是物理内存的1/64
  JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；
  空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
  因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。
对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：
JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；
由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。
-Xmn2G：设置年轻代大小为2G。
-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。
```

#### 用过那些JVM命令？

```C
jps  JVM 进程状态工具。显示系统内的所有 JVM 进程。
jstat  JVM 统计监控工具。监控虚拟机运行时状态信息，
  它可以显示出 JVM 进程中的类装载、内存、GC、JIT 编译等运行数据。
jmap  JVM 堆内存分析工具。用于打印 JVM 进程对象直方图、类加载统计。
  并且可以生成堆转储快照（一般称为 heapdump 或 dump 文件）。
jstack  JVM 栈查看工具。用于打印 JVM 进程的线程和锁的情况。
  并且可以生成线程快照（一般称为 threaddump 或 javacore 文件）。
jhat  用来分析 jmap 生成的 dump 文件。
jinfo  JVM 信息查看工具。用于实时查看和调整 JVM 进程参数。
jcmd  JVM 命令行调试 工具。用于向 JVM 进程发送调试命令。

这里可以说说一个应用场景？
```

#### JVM 由哪些部分组成？

```text
JVM 的结构基本上由 4 部分组成：
    1. **类加载器**，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中
    2. **执行引擎**，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU
    3. **内存分区**，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，
      如实际机器上的各种功能的寄存器或者 PC 指针的记录器等
    4. **本地方法调用**，调用 C 或 C++ 实现的本地方法的代码返回结果
```

#### 能讲讲类加载的过程吗？

```C
java 类加载需要经历以下7个过程：
1. 加载
  在这个阶段，将完成三件事情：
  （1）通过一个类的全限定名获取该类的二进制流
  （2）将该二进制流中的静态数据结构转化为方法区运行时数据结构
  （3）在内存中生成该类的 class 对象，作为该类的数据访问入口
2. 验证
  验证的目的是为了确保 class 文件字节流的信息不会危害到虚拟机，该阶段完成四种验证：
  （1）文件格式验证：验证字节流是否符合 class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池
  中的常量是否有不被支持的类型
  （2）元数据验证：对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等
  （3）字节码验证：
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载
```

## 类加载器

#### 类加载器有了解吗？

```text
类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。

一般来说，Java 虚拟机使用 Java 类的方式如下：
    1. Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）
    2. 类加载器负责读取 Java 字节代码，并加载到内存中
    每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。

实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。
```

#### Java 虚拟机是如何判定两个 Java 类是相同的？

```text
两个前提：
1. 类的全名是否相同
2. 加载此类的类加载器是否一样。
只有两者都相同的情况，才认为两个类是相同的。


比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。
  两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，
  并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。
  对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，
  会抛出运行时异常 ClassCastException。
```

#### ClassLoader 的分类及加载顺序?

```Java
boostrap classLoader
exg 拓展
Application 应用
自定义类加载器
```

#### 描述一下JVM加载class文件的原理机制？

```Java
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，
  Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。

类的加载是指把类的.class文件中的数据读入到内存中，
  通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。
  加载完成后，Class对象还不完整，所以此时的类还不可用。
  
  当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）
    和解析（将符号引用替换为直接引用）三个步骤。
  最后JVM对类进行初始化，包括：
    1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；
    2)如果类中存在初始化语句，就依次执行这些初始化语句。

类的加载是由类加载器完成的，类加载器包括：
  根加载器（BootStrap）
  扩展加载器（Extension）
  系统加载器（System）
  用户自定义类加载器（java.lang.ClassLoader的子类）。
  从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。
  PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，
    其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，
    父类加载器无能为力时才由其子类加载器自行加载。
  JVM不会向Java程序提供对Bootstrap的引用。
下面是关于几个类加载器的说明：
Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。
  它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，
    是用户自定义加载器的默认父加载器。
```

### JAVA类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机 制是什么意思？有什么好处?

- [深入理解Java类加载器(ClassLoader)](https://blog.csdn.net/javazejian/article/details/73413292/)

### 下面给出的Java中关于ClassLoader 的描述，哪些描述是正确的？

- A. ClassLoader 没有层次关系

- B. 所有类中的 ClassLoader 都是 APPClassLoader

- C. 通过 Class.forName(String className) 能够动态加载一个类

- D. 不同的 ClassLoader 加载同一个 Class 文件，所得的类是相同的

**解析：**

```text
A 选项错误，ClassLoader 具备层次关系
B 选项错误，ClassLoader 不止一种
D 选项错误，不同的类加载器分别创建的同一个类的字节码数据属于完全不同的对象，没有任何关联
答案：C

```

**扩展知识：**

#### ClassLoader 基本概念

与 C 或 C++ 编写的程序不同，Java 程序并不是一个可执行文件，而是由许多独立的类文件组成的，每一个文件对应一个 Java 类。

此外，这些类文件并非全部装入内存，而是根据程序需要逐渐载入。 ClassLoader 是 JVM 实现的一部分，ClassLoader 包括 bootstrapClassLoader（气动类加载器），ClassLoader 在 JVM 运行的时候加载 Java 核心的 API，以满足 Java 程序组基本的需求，其中就包括用户定义的 ClassLoader，这里所谓的用户定义，是指通过 Java 程序实现的两个 ClassLoader：一个是 ExtClassLoader，它的作用是用来加载 Java 的扩展APi，也就是 /lib/ext 中的类；第二个是 APPClassLoader，它是用来加载用户机器上 CLASSPATH 设置目录中的 Class 的， 通常在没有指定 ClassLoader 的情况下，程序员自定义的类就由该 CLassLoader 进行加载。

#### CLassLoader 的加载流程

当运行一个程序的时候， JVM 启动，运行 boostrapClassLader，该 ClassLoader 加载 Java 核心APi（ExtClassLoader 和 APPClassLoader 也在此时加载），然后调用 ExtClassLoader 加载扩展API，最后 APPClassLoader 加载 CLASSPATH 目录下定义的 Class，这就是一个程序最基本的加载流程。

## 执行引擎

## 内存分区

也叫运行时数据区，包含堆，栈、方法区、程序计数器、本地方法栈等。

### 从整体来看内存分区

#### 内存模型以及分区，需要详细到每个区放什么？

```Java
JVM 分为堆、栈、方法区、本地方法栈、程序计数器
1. 方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字
  节码）等数据
2. 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要
  在堆上分配
3. 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作
  数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还
  是一个指向地址的指针
4. 本地方法栈：主要为 Native 方法服务
5. 程序计数器：记录当前线程执行的行号
```

#### String s = new String("xyz");创建了几个字符串对象？

```text
1.常量池中没有“xyz”对象，首先在常量池创建一个“xyz”对象，
  再在堆中创建一个new String(“xyz”)对象。共创建了两个对象。
2.常量池中原先已经存在了“xyz”对象了，此时只需在堆中创建一个new String(“xyz”)对象。
  共创建一个对象。
```

#### 深拷贝 和 浅拷贝

```text
浅拷贝被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。
  即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。
  ”里面的对象“会在原来的对象和它的副本之间共享。
  **简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。**
深拷贝深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。
  当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
  **简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。**
```

### 内存之堆

![](https://secure.wostatic.cn/static/sr64BE62QNrKnnpj68DQyq/b503ccf508e657ee0a8e15af4b7a594d.png)

#### 什么是堆？

```text
java 堆是虚拟机所管理的内存中最大的一块空间，是所有线程共享的一块内存区域，在虚拟机启动时创建。

此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

1. 通过 new 关键字创建的对象存放在堆中
2. 所有线程会共享同一个堆内存
3. 在堆内存中是有垃圾回收机制的=
```

#### 知道内存溢出和内存泄漏吗？

```text
内存泄漏：创建了很多的对象存放在堆内存中，GC回收了很多次就是无法清理改垃圾对象
内存溢出：就是满了呗
```



#### 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点？

```Java
堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace）。
新生代：
  包含Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制
算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到
老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区
当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice
区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎
片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，
就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，
就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存
活时间一般比较久远。
```

### 内存之常量池

#### 什么是常量池？

```text
**用于保存在编译期已确定的，已编译的class文件中的一份数据。**

它包括了关于类，方法，接口等中的常量，也包括字符串常量，
如String s = "java"这种申明方式；
当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。
```

#### 常量池分类？

```text
1. Class 文件常量池：java  编译 的 class 文件 还没有被类加载器加载该class 文件
2. 运行时常量池：类加载器读取class文件到内存中，该常量池就是运行时常量池
3. 全局字符串常量池：
    JDK7以前是在 方法区
    JDK 7 是在 堆中
    JDK7以后 方法区改元空间（方法区新的实现） 字符串常量池还是存放在我们的堆中。
```

### 内存之GC

#### GC 的两种判定方法？

```Java
1. 引用计数法
  如果某个地方引用了这个对象就将+1，如果失效了就-1，当为0时就会回收
  但是这种方法有个问题：无法判断循环引用（A引用B，B引用A）的情况
2. 引用链法（可达性分析）
  通过一种GC ROOT的对象
  （虚拟机栈（栈帧中的本地变量表）中引用的对象、
  方法区中类静态属性引用的对象、
  方法区中常量引用的对象、
  本地方法栈中JNI（即一般说的Native方法）引用的对象）来判断，
  如果有一条链能够到达GC ROOT就说明，对象还在被引用，
  不能到达GC ROOT就说明对象已经不再被引用，可以回收

```

#### SafePoint 是什么？

```Java
safepoint就是一个安全点，所有的线程执行到安全点的时候就会去检查是否需要执行safepoint操作，
  如果需要执行，那么所有的线程都将会等待，直到所有的线程进入safepoint。
  然后JVM执行相应的操作之后，所有的线程再恢复执行。
  
线程什么时候会进入safepoint？
  1. 线程在竞争锁被阻塞，IO被阻塞，或者在等待获得监视器锁状态时 
  2. 再执行JNI代码的那一刻
```

#### GC的三种收集算法？

```Java
1. 标记清除算法
2. 标记整理算法
3. 复制算法
```

## 未分类

#### 64 位JVM中，int 的长度是多少？

```Java
java中 int类型变量的长度是一个固定值，与平台无关，都是32位。
不管是64位还是32位的java虚拟机中，int类型的长度是相同的。
```

#### Serial 与 parallel GC之间的区别？

```Java
Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。
他们之间主要不同：
  Serial 收集器是默认的复制收集器，执行 GC的时候只有一个线程
  Parallel 收集器使用多个GC线程来执行。

```

#### java 中 WeakReference 与 SoftReference 的区别？

```Java
虽然 WeakReference 与softReference 都有利于 GC 和 内存的效率。
  但是 WeakReference 一旦失去最后一个强引用，就会被 GC回收，而软引用虽然不能阻止被回收，
  但是可以延迟到 JVM 内存不足的时候。

```

#### WeakHashMap 是怎么工作的？

```Java
WeakHashMap 的工作与正常的hashMap 类似，但是使用弱引用作为 key。

这意味着：当 key 对象没有任何引用的时候，key/value 将会被回收。
```