### 概念

#### 什么是 redis ？

```text
Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
1. Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
2. Redis不仅仅支持简单的key-value类型的数据，同时还提供String、list，set，zset，hash等数据结构的存储。
3. Redis支持数据的备份，即master-slave模式的数据备份。
```

#### Redis有哪些适合的场景？

```text
1）Session共享(单点登录)
2）页面缓存
3）队列
4）排行榜/计数器
5）发布/订阅
```

### 具体使用

#### Redis支持哪几种数据类型？

```text
支持多种类型的数据结构
1.string：最基本的数据类型，二进制安全的字符串，最大512M。
2.list：按照添加顺序保持顺序的字符串列表。
3.set：无序的字符串集合，不存在重复的元素。
4.sorted set：已排序的字符串集合。
5.hash：key-value对的一种集合。
```

#### 一个字符串类型的值能存储最大容量是多少？

```text
512M
```

#### redis 过期键的删除策略？

```C
（1）定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。
（2）惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
（3）定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

关键词：定时 定期 惰性
    定时：定时器，键的过期时间到了就立即执行键删除操作。
    定期：定期数据库检查，删除里面的过期键
    惰性：获取键时，检查取得的键是否过期
```

#### Redis提供了哪几种持久化方式？

```text
Redis 提供两种持久化机制 RDB 和 AOF 机制。

RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储
AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据

RDB：快照
AOF：日志记录
```

#### Redis 回收策略（淘汰策略）

```text
总共6种策略。

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据

记：两种数据集（volatile、allkeys），三种淘汰策略（lru、ttl、random）进行组合，再加上一种 no-eviction 永不回收策略

使用策略规则：
1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random
```

#### Redis 的同步机制了解么？

```text
答：Redis 可以使用主从同步，从从同步。

第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。
加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。
```

#### pipeline 有什么好处，为什么要使用 pipeline？

```text
可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。
使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS峰值的一个重要因素是 pipeline 批次指令的数目。
```

#### redis 缓存穿透 缓存击穿 缓存雪崩

```text
缓存穿透：
  key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，
  从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。

    解决方案：
    1. 布隆过滤器：拦截一定不存在的数据
    2. 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），缓存空数据设置较短的过期时间（一般不超过五分钟）

缓存击穿：
  key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

  解决方案：SETNX 只有不存在的时候才设置，互斥锁的效果

缓存雪崩：
  当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

  解决方案：
    1. 在原有的失效时间基础上加上一个随机值，降低重复频率
    2. 多级缓存
```

#### 使用过 Redis 分布式锁么，它是什么回事？

```text
先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

注：这里是两个操作，不具有原子性。

情况一：
  如果在 setnx 之后执行 expire之前进程意外 crash 或者要重启维护了，会出现锁无法释放的情况。
  解决方案：
    为了保证 这两个操作的原子性，可以使用 set 指令将这两条指令合称为一条指令来用。

情况二：
  过期时间已经到了，但是服务1还没有释放锁，那么就有可能会出现多个服务操作一个对象的场景？
  解决方案：
    思路一：任务执行的时候，开辟一个守护线程，在守护线程中每隔一段时间重新设置过期时间。
    思路二：通过Redisson中的看门狗来实现。

情况三：
如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。
但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。
接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。

简单来说就是：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。

    解决方案：
      Redisson 的 RedLock 算法
        遍历所有的Redis客户端，然后依次加锁，最后统计成功的次数来判断是否加锁成功。不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，n / 2 + 1，
        必须在大多数redis节点上都成功创建锁，才能算这个整体的RedLock加锁成功

```

#### 为什么要做 Redis 分区？

```C
分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。
分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。
```

#### 你知道有哪些 Redis 分区实现方案？

```C
客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读
取。大多数客户端已经实现了客户端分区。
代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。
代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis
和 memcached 的一种代理实现就是 Twemproxy
查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请
求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接
将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到
正确的 redis 节点
```

#### Redis 分区有什么缺点？

```C
涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集.
  因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。
同时操作多个 key,则不能使用 Redis 事务.
分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning 
granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big 
sorted set）.
当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集 RDB / AOF 文件。
分区时动态扩容或缩容可能非常复杂。
```

### redis 命令

#### redis 常用命令

```C


```

#### Redis key 的过期时间和永久有效分别怎么设置？

```text
EXPIRE 和 PERSIST 命令。
```

#### Redis 事务相关的命令有哪几个？

```C
MULTI、EXEC、DISCARD、WATCH
```

### redis 集群

#### Redis哈希槽的概念？

```text
Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。
```

#### Redis集群最大节点个数是多少？

```text
Redis集群预分好16384个桶(哈希槽)
```

#### Redis集群的主从复制模型是怎样的？

```text
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.
```

#### Redis集群会有写操作丢失吗？为什么？

```text
Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
```

#### Redis集群之间是如何复制的？

```text
异步复制
```

#### Redis 集群最大节点个数是多少？

```text
16384 个
怎么来的？
```

#### Redis如何做内存优化？

```text
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。
```

#### Redis集群方案应该怎么做？都有哪些方案？

```text
1.twemproxy
2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。
3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。
```

### 底层原理

#### Redis 为什么快？redis 6.0 之后为什么改为多线程？

```text
1.redis是基于内存的，内存的读写速度非常快；
2.redis是单线程的，省去了很多上下文切换线程的时间；
3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。
epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

Redis6.0的多线程是指，将**网络数据读写**和**协议解析**通过多线程的方式来处理，对于**命令执行来说，仍然使用单线程操作**。也就是说，Redis6.0的多线程是为了解决其网络IO的瓶颈
```

### 性能优化

#### Redis 常见性能问题和解决方案？

```text
1、Master 最好不要写内存快照
2、如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
3、为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网
4、尽量避免在压力很大的主库上增加从
5、主从复制不要用图状结构，用单向链表结构更为稳定
```

